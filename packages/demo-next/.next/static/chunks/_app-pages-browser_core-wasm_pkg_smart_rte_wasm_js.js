"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_core-wasm_pkg_smart_rte_wasm_js"],{

/***/ "(app-pages-browser)/../core-wasm/pkg/smart_rte_wasm.js":
/*!******************************************!*\
  !*** ../core-wasm/pkg/smart_rte_wasm.js ***!
  \******************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: function() { return /* binding */ Editor; },\n/* harmony export */   initSync: function() { return /* binding */ initSync; }\n/* harmony export */ });\nlet wasm;\nlet cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\nlet cachedTextDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", {\n    ignoreBOM: true,\n    fatal: true\n}) : {\n    decode: ()=>{\n        throw Error(\"TextDecoder not available\");\n    }\n};\nif (typeof TextDecoder !== \"undefined\") {\n    cachedTextDecoder.decode();\n}\n;\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", {\n            ignoreBOM: true,\n            fatal: true\n        }) : {\n            decode: ()=>{\n                throw Error(\"TextDecoder not available\");\n            }\n        };\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\nlet WASM_VECTOR_LEN = 0;\nconst cachedTextEncoder = typeof TextEncoder !== \"undefined\" ? new TextEncoder(\"utf-8\") : {\n    encode: ()=>{\n        throw Error(\"TextEncoder not available\");\n    }\n};\nconst encodeString = typeof cachedTextEncoder.encodeInto === \"function\" ? function(arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n} : function(arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n};\nfunction passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n    const mem = getUint8ArrayMemory0();\n    let offset = 0;\n    for(; offset < len; offset++){\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\nconst EditorFinalization = typeof FinalizationRegistry === \"undefined\" ? {\n    register: ()=>{},\n    unregister: ()=>{}\n} : new FinalizationRegistry((ptr)=>wasm.__wbg_editor_free(ptr >>> 0, 1));\nclass Editor {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Editor.prototype);\n        obj.__wbg_ptr = ptr;\n        EditorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EditorFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_editor_free(ptr, 0);\n    }\n    /**\n     * @returns {Editor}\n     */ static new_empty() {\n        const ret = wasm.editor_new();\n        return Editor.__wrap(ret);\n    }\n    /**\n     * @param {string} json\n     * @returns {Editor}\n     */ static from_json(json) {\n        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.editor_from_json(ptr0, len0);\n        return Editor.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */ to_json() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.editor_to_json(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally{\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {string}\n     */ to_html() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.editor_to_html(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally{\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {string}\n     */ to_markdown() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.editor_to_markdown(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally{\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {number} rows\n     * @param {number} cols\n     */ insert_table(rows, cols) {\n        wasm.editor_insert_table(this.__wbg_ptr, rows, cols);\n    }\n    /**\n     * @param {number} at\n     */ add_row(at) {\n        wasm.editor_add_row(this.__wbg_ptr, at);\n    }\n    /**\n     * @param {number} at\n     */ add_col(at) {\n        wasm.editor_add_col(this.__wbg_ptr, at);\n    }\n    /**\n     * @param {number} from\n     * @param {number} to\n     */ move_row(from, to) {\n        wasm.editor_move_row(this.__wbg_ptr, from, to);\n    }\n    /**\n     * @param {number} from\n     * @param {number} to\n     */ move_col(from, to) {\n        wasm.editor_move_col(this.__wbg_ptr, from, to);\n    }\n    /**\n     * @param {number} sr\n     * @param {number} sc\n     * @param {number} er\n     * @param {number} ec\n     */ merge_cells(sr, sc, er, ec) {\n        wasm.editor_merge_cells(this.__wbg_ptr, sr, sc, er, ec);\n    }\n    /**\n     * @param {number} r\n     * @param {number} c\n     */ split_cell(r, c) {\n        wasm.editor_split_cell(this.__wbg_ptr, r, c);\n    }\n    /**\n     * @param {number} r\n     * @param {number} c\n     * @param {string} style_json\n     */ set_cell_style(r, c, style_json) {\n        const ptr0 = passStringToWasm0(style_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.editor_set_cell_style(this.__wbg_ptr, r, c, ptr0, len0);\n    }\n    /**\n     * @param {number} col\n     * @param {number} px\n     */ set_column_width(col, px) {\n        wasm.editor_set_column_width(this.__wbg_ptr, col, px);\n    }\n    /**\n     * @param {boolean} header\n     * @param {boolean} first_col\n     */ set_freeze(header, first_col) {\n        wasm.editor_set_freeze(this.__wbg_ptr, header, first_col);\n    }\n    undo() {\n        wasm.editor_undo(this.__wbg_ptr);\n    }\n    redo() {\n        wasm.editor_redo(this.__wbg_ptr);\n    }\n    /**\n     * @param {string} anchor_json\n     * @param {string} text\n     * @returns {string}\n     */ add_comment(anchor_json, text) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const ptr0 = passStringToWasm0(anchor_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            const ret = wasm.editor_add_comment(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            deferred3_0 = ret[0];\n            deferred3_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally{\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n    /**\n     * @param {string} thread_id\n     * @param {boolean} resolved\n     */ resolve_comment(thread_id, resolved) {\n        const ptr0 = passStringToWasm0(thread_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.editor_resolve_comment(this.__wbg_ptr, ptr0, len0, resolved);\n    }\n    constructor(){\n        const ret = wasm.editor_new();\n        this.__wbg_ptr = ret >>> 0;\n        EditorFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\nconst EXPECTED_RESPONSE_TYPES = new Set([\n    \"basic\",\n    \"cors\",\n    \"default\"\n]);\nasync function __wbg_load(module, imports) {\n    if (typeof Response === \"function\" && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === \"function\") {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n            } catch (e) {\n                const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);\n                if (validResponse && module.headers.get(\"Content-Type\") !== \"application/wasm\") {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n                } else {\n                    throw e;\n                }\n            }\n        }\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n        if (instance instanceof WebAssembly.Instance) {\n            return {\n                instance,\n                module\n            };\n        } else {\n            return instance;\n        }\n    }\n}\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_wbindgenthrow_4c11a24fca429ccf = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_0;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n    return imports;\n}\nfunction __wbg_init_memory(imports, memory) {}\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n}\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n    if (typeof module !== \"undefined\") {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({ module } = module);\n        } else {\n            console.warn(\"using deprecated parameters for `initSync()`; pass a single object instead\");\n        }\n    }\n    const imports = __wbg_get_imports();\n    __wbg_init_memory(imports);\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n    const instance = new WebAssembly.Instance(module, imports);\n    return __wbg_finalize_init(instance, module);\n}\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n    if (typeof module_or_path !== \"undefined\") {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({ module_or_path } = module_or_path);\n        } else {\n            console.warn(\"using deprecated parameters for the initialization function; pass a single object instead\");\n        }\n    }\n    if (typeof module_or_path === \"undefined\") {\n        module_or_path = /* asset import */ new __webpack_require__.U(__webpack_require__(/*! smart_rte_wasm_bg.wasm */ \"(app-pages-browser)/../core-wasm/pkg/smart_rte_wasm_bg.wasm\"));\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === \"string\" || typeof Request === \"function\" && module_or_path instanceof Request || typeof URL === \"function\" && module_or_path instanceof URL) {\n        module_or_path = fetch(module_or_path);\n    }\n    __wbg_init_memory(imports);\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (__wbg_init);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9jb3JlLXdhc20vcGtnL3NtYXJ0X3J0ZV93YXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUE7QUFFSixJQUFJQywwQkFBMEI7QUFFOUIsU0FBU0M7SUFDTCxJQUFJRCw0QkFBNEIsUUFBUUEsd0JBQXdCRSxVQUFVLEtBQUssR0FBRztRQUM5RUYsMEJBQTBCLElBQUlHLFdBQVdKLEtBQUtLLE1BQU0sQ0FBQ0MsTUFBTTtJQUMvRDtJQUNBLE9BQU9MO0FBQ1g7QUFFQSxJQUFJTSxvQkFBcUIsT0FBT0MsZ0JBQWdCLGNBQWMsSUFBSUEsWUFBWSxTQUFTO0lBQUVDLFdBQVc7SUFBTUMsT0FBTztBQUFLLEtBQUs7SUFBRUMsUUFBUTtRQUFRLE1BQU1DLE1BQU07SUFBNkI7QUFBRTtBQUV4TCxJQUFJLE9BQU9KLGdCQUFnQixhQUFhO0lBQUVELGtCQUFrQkksTUFBTTtBQUFJOztBQUV0RSxNQUFNRSwwQkFBMEI7QUFDaEMsSUFBSUMsa0JBQWtCO0FBQ3RCLFNBQVNDLFdBQVdDLEdBQUcsRUFBRUMsR0FBRztJQUN4QkgsbUJBQW1CRztJQUNuQixJQUFJSCxtQkFBbUJELHlCQUF5QjtRQUM1Q04sb0JBQXFCLE9BQU9DLGdCQUFnQixjQUFjLElBQUlBLFlBQVksU0FBUztZQUFFQyxXQUFXO1lBQU1DLE9BQU87UUFBSyxLQUFLO1lBQUVDLFFBQVE7Z0JBQVEsTUFBTUMsTUFBTTtZQUE2QjtRQUFFO1FBQ3BMTCxrQkFBa0JJLE1BQU07UUFDeEJHLGtCQUFrQkc7SUFDdEI7SUFDQSxPQUFPVixrQkFBa0JJLE1BQU0sQ0FBQ1QsdUJBQXVCZ0IsUUFBUSxDQUFDRixLQUFLQSxNQUFNQztBQUMvRTtBQUVBLFNBQVNFLG1CQUFtQkgsR0FBRyxFQUFFQyxHQUFHO0lBQ2hDRCxNQUFNQSxRQUFRO0lBQ2QsT0FBT0QsV0FBV0MsS0FBS0M7QUFDM0I7QUFFQSxJQUFJRyxrQkFBa0I7QUFFdEIsTUFBTUMsb0JBQXFCLE9BQU9DLGdCQUFnQixjQUFjLElBQUlBLFlBQVksV0FBVztJQUFFQyxRQUFRO1FBQVEsTUFBTVgsTUFBTTtJQUE2QjtBQUFFO0FBRXhKLE1BQU1ZLGVBQWdCLE9BQU9ILGtCQUFrQkksVUFBVSxLQUFLLGFBQ3hELFNBQVVDLEdBQUcsRUFBRUMsSUFBSTtJQUNyQixPQUFPTixrQkFBa0JJLFVBQVUsQ0FBQ0MsS0FBS0M7QUFDN0MsSUFDTSxTQUFVRCxHQUFHLEVBQUVDLElBQUk7SUFDckIsTUFBTUMsTUFBTVAsa0JBQWtCRSxNQUFNLENBQUNHO0lBQ3JDQyxLQUFLRSxHQUFHLENBQUNEO0lBQ1QsT0FBTztRQUNIRSxNQUFNSixJQUFJSyxNQUFNO1FBQ2hCQyxTQUFTSixJQUFJRyxNQUFNO0lBQ3ZCO0FBQ0o7QUFFQSxTQUFTRSxrQkFBa0JQLEdBQUcsRUFBRVEsTUFBTSxFQUFFQyxPQUFPO0lBRTNDLElBQUlBLFlBQVlDLFdBQVc7UUFDdkIsTUFBTVIsTUFBTVAsa0JBQWtCRSxNQUFNLENBQUNHO1FBQ3JDLE1BQU1WLE1BQU1rQixPQUFPTixJQUFJRyxNQUFNLEVBQUUsT0FBTztRQUN0QzdCLHVCQUF1QmdCLFFBQVEsQ0FBQ0YsS0FBS0EsTUFBTVksSUFBSUcsTUFBTSxFQUFFRixHQUFHLENBQUNEO1FBQzNEUixrQkFBa0JRLElBQUlHLE1BQU07UUFDNUIsT0FBT2Y7SUFDWDtJQUVBLElBQUlDLE1BQU1TLElBQUlLLE1BQU07SUFDcEIsSUFBSWYsTUFBTWtCLE9BQU9qQixLQUFLLE9BQU87SUFFN0IsTUFBTW9CLE1BQU1uQztJQUVaLElBQUlvQyxTQUFTO0lBRWIsTUFBT0EsU0FBU3JCLEtBQUtxQixTQUFVO1FBQzNCLE1BQU1DLE9BQU9iLElBQUljLFVBQVUsQ0FBQ0Y7UUFDNUIsSUFBSUMsT0FBTyxNQUFNO1FBQ2pCRixHQUFHLENBQUNyQixNQUFNc0IsT0FBTyxHQUFHQztJQUN4QjtJQUVBLElBQUlELFdBQVdyQixLQUFLO1FBQ2hCLElBQUlxQixXQUFXLEdBQUc7WUFDZFosTUFBTUEsSUFBSWUsS0FBSyxDQUFDSDtRQUNwQjtRQUNBdEIsTUFBTW1CLFFBQVFuQixLQUFLQyxLQUFLQSxNQUFNcUIsU0FBU1osSUFBSUssTUFBTSxHQUFHLEdBQUcsT0FBTztRQUM5RCxNQUFNSixPQUFPekIsdUJBQXVCZ0IsUUFBUSxDQUFDRixNQUFNc0IsUUFBUXRCLE1BQU1DO1FBQ2pFLE1BQU15QixNQUFNbEIsYUFBYUUsS0FBS0M7UUFFOUJXLFVBQVVJLElBQUlWLE9BQU87UUFDckJoQixNQUFNbUIsUUFBUW5CLEtBQUtDLEtBQUtxQixRQUFRLE9BQU87SUFDM0M7SUFFQWxCLGtCQUFrQmtCO0lBQ2xCLE9BQU90QjtBQUNYO0FBRUEsTUFBTTJCLHFCQUFxQixPQUFRQyx5QkFBeUIsY0FDdEQ7SUFBRUMsVUFBVSxLQUFPO0lBQUdDLFlBQVksS0FBTztBQUFFLElBQzNDLElBQUlGLHFCQUFxQjVCLENBQUFBLE1BQU9oQixLQUFLK0MsaUJBQWlCLENBQUMvQixRQUFRLEdBQUc7QUFFakUsTUFBTWdDO0lBRVQsT0FBT0MsT0FBT2pDLEdBQUcsRUFBRTtRQUNmQSxNQUFNQSxRQUFRO1FBQ2QsTUFBTWtDLE1BQU1DLE9BQU9DLE1BQU0sQ0FBQ0osT0FBT0ssU0FBUztRQUMxQ0gsSUFBSUksU0FBUyxHQUFHdEM7UUFDaEIyQixtQkFBbUJFLFFBQVEsQ0FBQ0ssS0FBS0EsSUFBSUksU0FBUyxFQUFFSjtRQUNoRCxPQUFPQTtJQUNYO0lBRUFLLHFCQUFxQjtRQUNqQixNQUFNdkMsTUFBTSxJQUFJLENBQUNzQyxTQUFTO1FBQzFCLElBQUksQ0FBQ0EsU0FBUyxHQUFHO1FBQ2pCWCxtQkFBbUJHLFVBQVUsQ0FBQyxJQUFJO1FBQ2xDLE9BQU85QjtJQUNYO0lBRUF3QyxPQUFPO1FBQ0gsTUFBTXhDLE1BQU0sSUFBSSxDQUFDdUMsa0JBQWtCO1FBQ25DdkQsS0FBSytDLGlCQUFpQixDQUFDL0IsS0FBSztJQUNoQztJQU9BOztLQUVDLEdBQ0QsT0FBT3lDLFlBQVk7UUFDZixNQUFNZixNQUFNMUMsS0FBSzBELFVBQVU7UUFDM0IsT0FBT1YsT0FBT0MsTUFBTSxDQUFDUDtJQUN6QjtJQUNBOzs7S0FHQyxHQUNELE9BQU9pQixVQUFVQyxJQUFJLEVBQUU7UUFDbkIsTUFBTUMsT0FBTzVCLGtCQUFrQjJCLE1BQU01RCxLQUFLOEQsaUJBQWlCLEVBQUU5RCxLQUFLK0Qsa0JBQWtCO1FBQ3BGLE1BQU1DLE9BQU81QztRQUNiLE1BQU1zQixNQUFNMUMsS0FBS2lFLGdCQUFnQixDQUFDSixNQUFNRztRQUN4QyxPQUFPaEIsT0FBT0MsTUFBTSxDQUFDUDtJQUN6QjtJQUNBOztLQUVDLEdBQ0R3QixVQUFVO1FBQ04sSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUk7WUFDQSxNQUFNMUIsTUFBTTFDLEtBQUtxRSxjQUFjLENBQUMsSUFBSSxDQUFDZixTQUFTO1lBQzlDYSxjQUFjekIsR0FBRyxDQUFDLEVBQUU7WUFDcEIwQixjQUFjMUIsR0FBRyxDQUFDLEVBQUU7WUFDcEIsT0FBT3ZCLG1CQUFtQnVCLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFO1FBQzVDLFNBQVU7WUFDTjFDLEtBQUtzRSxlQUFlLENBQUNILGFBQWFDLGFBQWE7UUFDbkQ7SUFDSjtJQUNBOztLQUVDLEdBQ0RHLFVBQVU7UUFDTixJQUFJSjtRQUNKLElBQUlDO1FBQ0osSUFBSTtZQUNBLE1BQU0xQixNQUFNMUMsS0FBS3dFLGNBQWMsQ0FBQyxJQUFJLENBQUNsQixTQUFTO1lBQzlDYSxjQUFjekIsR0FBRyxDQUFDLEVBQUU7WUFDcEIwQixjQUFjMUIsR0FBRyxDQUFDLEVBQUU7WUFDcEIsT0FBT3ZCLG1CQUFtQnVCLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFO1FBQzVDLFNBQVU7WUFDTjFDLEtBQUtzRSxlQUFlLENBQUNILGFBQWFDLGFBQWE7UUFDbkQ7SUFDSjtJQUNBOztLQUVDLEdBQ0RLLGNBQWM7UUFDVixJQUFJTjtRQUNKLElBQUlDO1FBQ0osSUFBSTtZQUNBLE1BQU0xQixNQUFNMUMsS0FBSzBFLGtCQUFrQixDQUFDLElBQUksQ0FBQ3BCLFNBQVM7WUFDbERhLGNBQWN6QixHQUFHLENBQUMsRUFBRTtZQUNwQjBCLGNBQWMxQixHQUFHLENBQUMsRUFBRTtZQUNwQixPQUFPdkIsbUJBQW1CdUIsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7UUFDNUMsU0FBVTtZQUNOMUMsS0FBS3NFLGVBQWUsQ0FBQ0gsYUFBYUMsYUFBYTtRQUNuRDtJQUNKO0lBQ0E7OztLQUdDLEdBQ0RPLGFBQWFDLElBQUksRUFBRUMsSUFBSSxFQUFFO1FBQ3JCN0UsS0FBSzhFLG1CQUFtQixDQUFDLElBQUksQ0FBQ3hCLFNBQVMsRUFBRXNCLE1BQU1DO0lBQ25EO0lBQ0E7O0tBRUMsR0FDREUsUUFBUUMsRUFBRSxFQUFFO1FBQ1JoRixLQUFLaUYsY0FBYyxDQUFDLElBQUksQ0FBQzNCLFNBQVMsRUFBRTBCO0lBQ3hDO0lBQ0E7O0tBRUMsR0FDREUsUUFBUUYsRUFBRSxFQUFFO1FBQ1JoRixLQUFLbUYsY0FBYyxDQUFDLElBQUksQ0FBQzdCLFNBQVMsRUFBRTBCO0lBQ3hDO0lBQ0E7OztLQUdDLEdBQ0RJLFNBQVNDLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQ2Z0RixLQUFLdUYsZUFBZSxDQUFDLElBQUksQ0FBQ2pDLFNBQVMsRUFBRStCLE1BQU1DO0lBQy9DO0lBQ0E7OztLQUdDLEdBQ0RFLFNBQVNILElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQ2Z0RixLQUFLeUYsZUFBZSxDQUFDLElBQUksQ0FBQ25DLFNBQVMsRUFBRStCLE1BQU1DO0lBQy9DO0lBQ0E7Ozs7O0tBS0MsR0FDREksWUFBWUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ3hCOUYsS0FBSytGLGtCQUFrQixDQUFDLElBQUksQ0FBQ3pDLFNBQVMsRUFBRXFDLElBQUlDLElBQUlDLElBQUlDO0lBQ3hEO0lBQ0E7OztLQUdDLEdBQ0RFLFdBQVdDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2JsRyxLQUFLbUcsaUJBQWlCLENBQUMsSUFBSSxDQUFDN0MsU0FBUyxFQUFFMkMsR0FBR0M7SUFDOUM7SUFDQTs7OztLQUlDLEdBQ0RFLGVBQWVILENBQUMsRUFBRUMsQ0FBQyxFQUFFRyxVQUFVLEVBQUU7UUFDN0IsTUFBTXhDLE9BQU81QixrQkFBa0JvRSxZQUFZckcsS0FBSzhELGlCQUFpQixFQUFFOUQsS0FBSytELGtCQUFrQjtRQUMxRixNQUFNQyxPQUFPNUM7UUFDYnBCLEtBQUtzRyxxQkFBcUIsQ0FBQyxJQUFJLENBQUNoRCxTQUFTLEVBQUUyQyxHQUFHQyxHQUFHckMsTUFBTUc7SUFDM0Q7SUFDQTs7O0tBR0MsR0FDRHVDLGlCQUFpQkMsR0FBRyxFQUFFQyxFQUFFLEVBQUU7UUFDdEJ6RyxLQUFLMEcsdUJBQXVCLENBQUMsSUFBSSxDQUFDcEQsU0FBUyxFQUFFa0QsS0FBS0M7SUFDdEQ7SUFDQTs7O0tBR0MsR0FDREUsV0FBV0MsTUFBTSxFQUFFQyxTQUFTLEVBQUU7UUFDMUI3RyxLQUFLOEcsaUJBQWlCLENBQUMsSUFBSSxDQUFDeEQsU0FBUyxFQUFFc0QsUUFBUUM7SUFDbkQ7SUFDQUUsT0FBTztRQUNIL0csS0FBS2dILFdBQVcsQ0FBQyxJQUFJLENBQUMxRCxTQUFTO0lBQ25DO0lBQ0EyRCxPQUFPO1FBQ0hqSCxLQUFLa0gsV0FBVyxDQUFDLElBQUksQ0FBQzVELFNBQVM7SUFDbkM7SUFDQTs7OztLQUlDLEdBQ0Q2RCxZQUFZQyxXQUFXLEVBQUVDLElBQUksRUFBRTtRQUMzQixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSTtZQUNBLE1BQU0xRCxPQUFPNUIsa0JBQWtCbUYsYUFBYXBILEtBQUs4RCxpQkFBaUIsRUFBRTlELEtBQUsrRCxrQkFBa0I7WUFDM0YsTUFBTUMsT0FBTzVDO1lBQ2IsTUFBTW9HLE9BQU92RixrQkFBa0JvRixNQUFNckgsS0FBSzhELGlCQUFpQixFQUFFOUQsS0FBSytELGtCQUFrQjtZQUNwRixNQUFNMEQsT0FBT3JHO1lBQ2IsTUFBTXNCLE1BQU0xQyxLQUFLMEgsa0JBQWtCLENBQUMsSUFBSSxDQUFDcEUsU0FBUyxFQUFFTyxNQUFNRyxNQUFNd0QsTUFBTUM7WUFDdEVILGNBQWM1RSxHQUFHLENBQUMsRUFBRTtZQUNwQjZFLGNBQWM3RSxHQUFHLENBQUMsRUFBRTtZQUNwQixPQUFPdkIsbUJBQW1CdUIsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7UUFDNUMsU0FBVTtZQUNOMUMsS0FBS3NFLGVBQWUsQ0FBQ2dELGFBQWFDLGFBQWE7UUFDbkQ7SUFDSjtJQUNBOzs7S0FHQyxHQUNESSxnQkFBZ0JDLFNBQVMsRUFBRUMsUUFBUSxFQUFFO1FBQ2pDLE1BQU1oRSxPQUFPNUIsa0JBQWtCMkYsV0FBVzVILEtBQUs4RCxpQkFBaUIsRUFBRTlELEtBQUsrRCxrQkFBa0I7UUFDekYsTUFBTUMsT0FBTzVDO1FBQ2JwQixLQUFLOEgsc0JBQXNCLENBQUMsSUFBSSxDQUFDeEUsU0FBUyxFQUFFTyxNQUFNRyxNQUFNNkQ7SUFDNUQ7SUFoTEFFLGFBQWM7UUFDVixNQUFNckYsTUFBTTFDLEtBQUswRCxVQUFVO1FBQzNCLElBQUksQ0FBQ0osU0FBUyxHQUFHWixRQUFRO1FBQ3pCQyxtQkFBbUJFLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDUyxTQUFTLEVBQUUsSUFBSTtRQUN0RCxPQUFPLElBQUk7SUFDZjtBQTRLSjtBQUVBLE1BQU0wRSwwQkFBMEIsSUFBSUMsSUFBSTtJQUFDO0lBQVM7SUFBUTtDQUFVO0FBRXBFLGVBQWVDLFdBQVdDLE1BQU0sRUFBRUMsT0FBTztJQUNyQyxJQUFJLE9BQU9DLGFBQWEsY0FBY0Ysa0JBQWtCRSxVQUFVO1FBQzlELElBQUksT0FBT0MsWUFBWUMsb0JBQW9CLEtBQUssWUFBWTtZQUN4RCxJQUFJO2dCQUNBLE9BQU8sTUFBTUQsWUFBWUMsb0JBQW9CLENBQUNKLFFBQVFDO1lBRTFELEVBQUUsT0FBT0ksR0FBRztnQkFDUixNQUFNQyxnQkFBZ0JOLE9BQU9PLEVBQUUsSUFBSVYsd0JBQXdCVyxHQUFHLENBQUNSLE9BQU9TLElBQUk7Z0JBRTFFLElBQUlILGlCQUFpQk4sT0FBT1UsT0FBTyxDQUFDQyxHQUFHLENBQUMsb0JBQW9CLG9CQUFvQjtvQkFDNUVDLFFBQVFDLElBQUksQ0FBQyxxTUFBcU1SO2dCQUV0TixPQUFPO29CQUNILE1BQU1BO2dCQUNWO1lBQ0o7UUFDSjtRQUVBLE1BQU1TLFFBQVEsTUFBTWQsT0FBT2UsV0FBVztRQUN0QyxPQUFPLE1BQU1aLFlBQVlhLFdBQVcsQ0FBQ0YsT0FBT2I7SUFFaEQsT0FBTztRQUNILE1BQU1nQixXQUFXLE1BQU1kLFlBQVlhLFdBQVcsQ0FBQ2hCLFFBQVFDO1FBRXZELElBQUlnQixvQkFBb0JkLFlBQVllLFFBQVEsRUFBRTtZQUMxQyxPQUFPO2dCQUFFRDtnQkFBVWpCO1lBQU87UUFFOUIsT0FBTztZQUNILE9BQU9pQjtRQUNYO0lBQ0o7QUFDSjtBQUVBLFNBQVNFO0lBQ0wsTUFBTWxCLFVBQVUsQ0FBQztJQUNqQkEsUUFBUW1CLEdBQUcsR0FBRyxDQUFDO0lBQ2ZuQixRQUFRbUIsR0FBRyxDQUFDQyxvQ0FBb0MsR0FBRyxTQUFTQyxJQUFJLEVBQUVDLElBQUk7UUFDbEUsTUFBTSxJQUFJOUksTUFBTU8sbUJBQW1Cc0ksTUFBTUM7SUFDN0M7SUFDQXRCLFFBQVFtQixHQUFHLENBQUNJLCtCQUErQixHQUFHO1FBQzFDLE1BQU1DLFFBQVE1SixLQUFLNkosbUJBQW1CO1FBQ3RDLE1BQU12SCxTQUFTc0gsTUFBTUUsSUFBSSxDQUFDO1FBQzFCRixNQUFNL0gsR0FBRyxDQUFDLEdBQUdPO1FBQ2J3SCxNQUFNL0gsR0FBRyxDQUFDUyxTQUFTLEdBQUdGO1FBQ3RCd0gsTUFBTS9ILEdBQUcsQ0FBQ1MsU0FBUyxHQUFHO1FBQ3RCc0gsTUFBTS9ILEdBQUcsQ0FBQ1MsU0FBUyxHQUFHO1FBQ3RCc0gsTUFBTS9ILEdBQUcsQ0FBQ1MsU0FBUyxHQUFHOztJQUUxQjtJQUVBLE9BQU84RjtBQUNYO0FBRUEsU0FBUzJCLGtCQUFrQjNCLE9BQU8sRUFBRS9ILE1BQU0sR0FFMUM7QUFFQSxTQUFTMkosb0JBQW9CWixRQUFRLEVBQUVqQixNQUFNO0lBQ3pDbkksT0FBT29KLFNBQVNhLE9BQU87SUFDdkJDLFdBQVdDLHNCQUFzQixHQUFHaEM7SUFDcENsSSwwQkFBMEI7SUFHMUJELEtBQUtvSyxnQkFBZ0I7SUFDckIsT0FBT3BLO0FBQ1g7QUFFQSxTQUFTcUssU0FBU2xDLE1BQU07SUFDcEIsSUFBSW5JLFNBQVNvQyxXQUFXLE9BQU9wQztJQUcvQixJQUFJLE9BQU9tSSxXQUFXLGFBQWE7UUFDL0IsSUFBSWhGLE9BQU9tSCxjQUFjLENBQUNuQyxZQUFZaEYsT0FBT0UsU0FBUyxFQUFFO1lBQ25ELEdBQUM4RSxNQUFNLEVBQUMsR0FBR0EsTUFBSztRQUNyQixPQUFPO1lBQ0hZLFFBQVFDLElBQUksQ0FBQztRQUNqQjtJQUNKO0lBRUEsTUFBTVosVUFBVWtCO0lBRWhCUyxrQkFBa0IzQjtJQUVsQixJQUFJLENBQUVELENBQUFBLGtCQUFrQkcsWUFBWWlDLE1BQU0sR0FBRztRQUN6Q3BDLFNBQVMsSUFBSUcsWUFBWWlDLE1BQU0sQ0FBQ3BDO0lBQ3BDO0lBRUEsTUFBTWlCLFdBQVcsSUFBSWQsWUFBWWUsUUFBUSxDQUFDbEIsUUFBUUM7SUFFbEQsT0FBTzRCLG9CQUFvQlosVUFBVWpCO0FBQ3pDO0FBRUEsZUFBZStCLFdBQVdNLGNBQWM7SUFDcEMsSUFBSXhLLFNBQVNvQyxXQUFXLE9BQU9wQztJQUcvQixJQUFJLE9BQU93SyxtQkFBbUIsYUFBYTtRQUN2QyxJQUFJckgsT0FBT21ILGNBQWMsQ0FBQ0Usb0JBQW9CckgsT0FBT0UsU0FBUyxFQUFFO1lBQzNELEdBQUNtSCxjQUFjLEVBQUMsR0FBR0EsY0FBYTtRQUNyQyxPQUFPO1lBQ0h6QixRQUFRQyxJQUFJLENBQUM7UUFDakI7SUFDSjtJQUVBLElBQUksT0FBT3dCLG1CQUFtQixhQUFhO1FBQ3ZDQSxpQkFBaUIsOEpBQWtEO0lBQ3ZFO0lBQ0EsTUFBTXBDLFVBQVVrQjtJQUVoQixJQUFJLE9BQU9rQixtQkFBbUIsWUFBYSxPQUFPRyxZQUFZLGNBQWNILDBCQUEwQkcsV0FBYSxPQUFPRixRQUFRLGNBQWNELDBCQUEwQkMsS0FBTTtRQUM1S0QsaUJBQWlCSSxNQUFNSjtJQUMzQjtJQUVBVCxrQkFBa0IzQjtJQUVsQixNQUFNLEVBQUVnQixRQUFRLEVBQUVqQixNQUFNLEVBQUUsR0FBRyxNQUFNRCxXQUFXLE1BQU1zQyxnQkFBZ0JwQztJQUVwRSxPQUFPNEIsb0JBQW9CWixVQUFVakI7QUFDekM7QUFFb0I7QUFDcEIsK0RBQWUrQixVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb3JlLXdhc20vcGtnL3NtYXJ0X3J0ZV93YXNtLmpzPzM4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHdhc207XG5cbmxldCBjYWNoZWRVaW50OEFycmF5TWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRVaW50OEFycmF5TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWRVaW50OEFycmF5TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwO1xufVxuXG5sZXQgY2FjaGVkVGV4dERlY29kZXIgPSAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSkgOiB7IGRlY29kZTogKCkgPT4geyB0aHJvdyBFcnJvcignVGV4dERlY29kZXIgbm90IGF2YWlsYWJsZScpIH0gfSApO1xuXG5pZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykgeyBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTsgfTtcblxuY29uc3QgTUFYX1NBRkFSSV9ERUNPREVfQllURVMgPSAyMTQ2NDM1MDcyO1xubGV0IG51bUJ5dGVzRGVjb2RlZCA9IDA7XG5mdW5jdGlvbiBkZWNvZGVUZXh0KHB0ciwgbGVuKSB7XG4gICAgbnVtQnl0ZXNEZWNvZGVkICs9IGxlbjtcbiAgICBpZiAobnVtQnl0ZXNEZWNvZGVkID49IE1BWF9TQUZBUklfREVDT0RFX0JZVEVTKSB7XG4gICAgICAgIGNhY2hlZFRleHREZWNvZGVyID0gKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pIDogeyBkZWNvZGU6ICgpID0+IHsgdGhyb3cgRXJyb3IoJ1RleHREZWNvZGVyIG5vdCBhdmFpbGFibGUnKSB9IH0gKTtcbiAgICAgICAgY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgIG51bUJ5dGVzRGVjb2RlZCA9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFRleHREZWNvZGVyLmRlY29kZShnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gZGVjb2RlVGV4dChwdHIsIGxlbik7XG59XG5cbmxldCBXQVNNX1ZFQ1RPUl9MRU4gPSAwO1xuXG5jb25zdCBjYWNoZWRUZXh0RW5jb2RlciA9ICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpIDogeyBlbmNvZGU6ICgpID0+IHsgdGhyb3cgRXJyb3IoJ1RleHRFbmNvZGVyIG5vdCBhdmFpbGFibGUnKSB9IH0gKTtcblxuY29uc3QgZW5jb2RlU3RyaW5nID0gKHR5cGVvZiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgcmV0dXJuIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8oYXJnLCB2aWV3KTtcbn1cbiAgICA6IGZ1bmN0aW9uIChhcmcsIHZpZXcpIHtcbiAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICB2aWV3LnNldChidWYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlYWQ6IGFyZy5sZW5ndGgsXG4gICAgICAgIHdyaXR0ZW46IGJ1Zi5sZW5ndGhcbiAgICB9O1xufSk7XG5cbmZ1bmN0aW9uIHBhc3NTdHJpbmdUb1dhc20wKGFyZywgbWFsbG9jLCByZWFsbG9jKSB7XG5cbiAgICBpZiAocmVhbGxvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgICAgICBjb25zdCBwdHIgPSBtYWxsb2MoYnVmLmxlbmd0aCwgMSkgPj4+IDA7XG4gICAgICAgIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBidWYubGVuZ3RoKS5zZXQoYnVmKTtcbiAgICAgICAgV0FTTV9WRUNUT1JfTEVOID0gYnVmLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBsZXQgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBsZXQgcHRyID0gbWFsbG9jKGxlbiwgMSkgPj4+IDA7XG5cbiAgICBjb25zdCBtZW0gPSBnZXRVaW50OEFycmF5TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMywgMSkgPj4+IDA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciArIG9mZnNldCwgcHRyICsgbGVuKTtcbiAgICAgICAgY29uc3QgcmV0ID0gZW5jb2RlU3RyaW5nKGFyZywgdmlldyk7XG5cbiAgICAgICAgb2Zmc2V0ICs9IHJldC53cml0dGVuO1xuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBvZmZzZXQsIDEpID4+PiAwO1xuICAgIH1cblxuICAgIFdBU01fVkVDVE9SX0xFTiA9IG9mZnNldDtcbiAgICByZXR1cm4gcHRyO1xufVxuXG5jb25zdCBFZGl0b3JGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZWRpdG9yX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3Ige1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEVkaXRvci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFZGl0b3JGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgRWRpdG9yRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19lZGl0b3JfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lZGl0b3JfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBFZGl0b3JGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0VkaXRvcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3X2VtcHR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVkaXRvcl9uZXcoKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpzb25cbiAgICAgKiBAcmV0dXJucyB7RWRpdG9yfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tX2pzb24oanNvbikge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoanNvbiwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVkaXRvcl9mcm9tX2pzb24ocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBFZGl0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9fanNvbigpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVkaXRvcl90b19qc29uKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b19odG1sKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uZWRpdG9yX3RvX2h0bWwodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByZXRbMF07XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHJldFsxXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocmV0WzBdLCByZXRbMV0pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvX21hcmtkb3duKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20uZWRpdG9yX3RvX21hcmtkb3duKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcmV0WzBdO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByZXRbMV07XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHJldFswXSwgcmV0WzFdKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sc1xuICAgICAqL1xuICAgIGluc2VydF90YWJsZShyb3dzLCBjb2xzKSB7XG4gICAgICAgIHdhc20uZWRpdG9yX2luc2VydF90YWJsZSh0aGlzLl9fd2JnX3B0ciwgcm93cywgY29scyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdFxuICAgICAqL1xuICAgIGFkZF9yb3coYXQpIHtcbiAgICAgICAgd2FzbS5lZGl0b3JfYWRkX3Jvdyh0aGlzLl9fd2JnX3B0ciwgYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXRcbiAgICAgKi9cbiAgICBhZGRfY29sKGF0KSB7XG4gICAgICAgIHdhc20uZWRpdG9yX2FkZF9jb2wodGhpcy5fX3diZ19wdHIsIGF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9cbiAgICAgKi9cbiAgICBtb3ZlX3Jvdyhmcm9tLCB0bykge1xuICAgICAgICB3YXNtLmVkaXRvcl9tb3ZlX3Jvdyh0aGlzLl9fd2JnX3B0ciwgZnJvbSwgdG8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1xuICAgICAqL1xuICAgIG1vdmVfY29sKGZyb20sIHRvKSB7XG4gICAgICAgIHdhc20uZWRpdG9yX21vdmVfY29sKHRoaXMuX193YmdfcHRyLCBmcm9tLCB0byk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlY1xuICAgICAqL1xuICAgIG1lcmdlX2NlbGxzKHNyLCBzYywgZXIsIGVjKSB7XG4gICAgICAgIHdhc20uZWRpdG9yX21lcmdlX2NlbGxzKHRoaXMuX193YmdfcHRyLCBzciwgc2MsIGVyLCBlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNcbiAgICAgKi9cbiAgICBzcGxpdF9jZWxsKHIsIGMpIHtcbiAgICAgICAgd2FzbS5lZGl0b3Jfc3BsaXRfY2VsbCh0aGlzLl9fd2JnX3B0ciwgciwgYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVfanNvblxuICAgICAqL1xuICAgIHNldF9jZWxsX3N0eWxlKHIsIGMsIHN0eWxlX2pzb24pIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHN0eWxlX2pzb24sIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5lZGl0b3Jfc2V0X2NlbGxfc3R5bGUodGhpcy5fX3diZ19wdHIsIHIsIGMsIHB0cjAsIGxlbjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHB4XG4gICAgICovXG4gICAgc2V0X2NvbHVtbl93aWR0aChjb2wsIHB4KSB7XG4gICAgICAgIHdhc20uZWRpdG9yX3NldF9jb2x1bW5fd2lkdGgodGhpcy5fX3diZ19wdHIsIGNvbCwgcHgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhlYWRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RfY29sXG4gICAgICovXG4gICAgc2V0X2ZyZWV6ZShoZWFkZXIsIGZpcnN0X2NvbCkge1xuICAgICAgICB3YXNtLmVkaXRvcl9zZXRfZnJlZXplKHRoaXMuX193YmdfcHRyLCBoZWFkZXIsIGZpcnN0X2NvbCk7XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIHdhc20uZWRpdG9yX3VuZG8odGhpcy5fX3diZ19wdHIpO1xuICAgIH1cbiAgICByZWRvKCkge1xuICAgICAgICB3YXNtLmVkaXRvcl9yZWRvKHRoaXMuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFuY2hvcl9qc29uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGFkZF9jb21tZW50KGFuY2hvcl9qc29uLCB0ZXh0KSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkM18xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFuY2hvcl9qc29uLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jLCB3YXNtLl9fd2JpbmRnZW5fcmVhbGxvYyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHRleHQsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLmVkaXRvcl9hZGRfY29tbWVudCh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICBkZWZlcnJlZDNfMCA9IHJldFswXTtcbiAgICAgICAgICAgIGRlZmVycmVkM18xID0gcmV0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyZXRbMF0sIHJldFsxXSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShkZWZlcnJlZDNfMCwgZGVmZXJyZWQzXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aHJlYWRfaWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc29sdmVkXG4gICAgICovXG4gICAgcmVzb2x2ZV9jb21tZW50KHRocmVhZF9pZCwgcmVzb2x2ZWQpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHRocmVhZF9pZCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLmVkaXRvcl9yZXNvbHZlX2NvbW1lbnQodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHJlc29sdmVkKTtcbiAgICB9XG59XG5cbmNvbnN0IEVYUEVDVEVEX1JFU1BPTlNFX1RZUEVTID0gbmV3IFNldChbJ2Jhc2ljJywgJ2NvcnMnLCAnZGVmYXVsdCddKTtcblxuYXN5bmMgZnVuY3Rpb24gX193YmdfbG9hZChtb2R1bGUsIGltcG9ydHMpIHtcbiAgICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZFJlc3BvbnNlID0gbW9kdWxlLm9rICYmIEVYUEVDVEVEX1JFU1BPTlNFX1RZUEVTLmhhcyhtb2R1bGUudHlwZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsaWRSZXNwb25zZSAmJiBtb2R1bGUuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9PSAnYXBwbGljYXRpb24vd2FzbScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nYCBmYWlsZWQgYmVjYXVzZSB5b3VyIHNlcnZlciBkb2VzIG5vdCBzZXJ2ZSBXYXNtIHdpdGggYGFwcGxpY2F0aW9uL3dhc21gIE1JTUUgdHlwZS4gRmFsbGluZyBiYWNrIHRvIGBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZWAgd2hpY2ggaXMgc2xvd2VyLiBPcmlnaW5hbCBlcnJvcjpcXG5cIiwgZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgbW9kdWxlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgaW1wb3J0cyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlLCBtb2R1bGUgfTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfX3diZ19nZXRfaW1wb3J0cygpIHtcbiAgICBjb25zdCBpbXBvcnRzID0ge307XG4gICAgaW1wb3J0cy53YmcgPSB7fTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ193YmluZGdlbnRocm93XzRjMTFhMjRmY2E0MjljY2YgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHdhc20uX193YmluZGdlbl9leHBvcnRfMDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGFibGUuZ3Jvdyg0KTtcbiAgICAgICAgdGFibGUuc2V0KDAsIHVuZGVmaW5lZCk7XG4gICAgICAgIHRhYmxlLnNldChvZmZzZXQgKyAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0YWJsZS5zZXQob2Zmc2V0ICsgMSwgbnVsbCk7XG4gICAgICAgIHRhYmxlLnNldChvZmZzZXQgKyAyLCB0cnVlKTtcbiAgICAgICAgdGFibGUuc2V0KG9mZnNldCArIDMsIGZhbHNlKTtcbiAgICAgICAgO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW1wb3J0cztcbn1cblxuZnVuY3Rpb24gX193YmdfaW5pdF9tZW1vcnkoaW1wb3J0cywgbWVtb3J5KSB7XG5cbn1cblxuZnVuY3Rpb24gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgd2FzbSA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgX193YmdfaW5pdC5fX3diaW5kZ2VuX3dhc21fbW9kdWxlID0gbW9kdWxlO1xuICAgIGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwID0gbnVsbDtcblxuXG4gICAgd2FzbS5fX3diaW5kZ2VuX3N0YXJ0KCk7XG4gICAgcmV0dXJuIHdhc207XG59XG5cbmZ1bmN0aW9uIGluaXRTeW5jKG1vZHVsZSkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUpID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAoe21vZHVsZX0gPSBtb2R1bGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVycyBmb3IgYGluaXRTeW5jKClgOyBwYXNzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGltcG9ydHMgPSBfX3diZ19nZXRfaW1wb3J0cygpO1xuXG4gICAgX193YmdfaW5pdF9tZW1vcnkoaW1wb3J0cyk7XG5cbiAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpKSB7XG4gICAgICAgIG1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobW9kdWxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9fd2JnX2luaXQobW9kdWxlX29yX3BhdGgpIHtcbiAgICBpZiAod2FzbSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gd2FzbTtcblxuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGVfb3JfcGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfb3JfcGF0aCkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICh7bW9kdWxlX29yX3BhdGh9ID0gbW9kdWxlX29yX3BhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVycyBmb3IgdGhlIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uOyBwYXNzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbW9kdWxlX29yX3BhdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1vZHVsZV9vcl9wYXRoID0gbmV3IFVSTCgnc21hcnRfcnRlX3dhc21fYmcud2FzbScsIGltcG9ydC5tZXRhLnVybCk7XG4gICAgfVxuICAgIGNvbnN0IGltcG9ydHMgPSBfX3diZ19nZXRfaW1wb3J0cygpO1xuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGVfb3JfcGF0aCA9PT0gJ3N0cmluZycgfHwgKHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZV9vcl9wYXRoIGluc3RhbmNlb2YgUmVxdWVzdCkgfHwgKHR5cGVvZiBVUkwgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlX29yX3BhdGggaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIG1vZHVsZV9vcl9wYXRoID0gZmV0Y2gobW9kdWxlX29yX3BhdGgpO1xuICAgIH1cblxuICAgIF9fd2JnX2luaXRfbWVtb3J5KGltcG9ydHMpO1xuXG4gICAgY29uc3QgeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBfX3diZ19sb2FkKGF3YWl0IG1vZHVsZV9vcl9wYXRoLCBpbXBvcnRzKTtcblxuICAgIHJldHVybiBfX3diZ19maW5hbGl6ZV9pbml0KGluc3RhbmNlLCBtb2R1bGUpO1xufVxuXG5leHBvcnQgeyBpbml0U3luYyB9O1xuZXhwb3J0IGRlZmF1bHQgX193YmdfaW5pdDtcbiJdLCJuYW1lcyI6WyJ3YXNtIiwiY2FjaGVkVWludDhBcnJheU1lbW9yeTAiLCJnZXRVaW50OEFycmF5TWVtb3J5MCIsImJ5dGVMZW5ndGgiLCJVaW50OEFycmF5IiwibWVtb3J5IiwiYnVmZmVyIiwiY2FjaGVkVGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsImlnbm9yZUJPTSIsImZhdGFsIiwiZGVjb2RlIiwiRXJyb3IiLCJNQVhfU0FGQVJJX0RFQ09ERV9CWVRFUyIsIm51bUJ5dGVzRGVjb2RlZCIsImRlY29kZVRleHQiLCJwdHIiLCJsZW4iLCJzdWJhcnJheSIsImdldFN0cmluZ0Zyb21XYXNtMCIsIldBU01fVkVDVE9SX0xFTiIsImNhY2hlZFRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJlbmNvZGVTdHJpbmciLCJlbmNvZGVJbnRvIiwiYXJnIiwidmlldyIsImJ1ZiIsInNldCIsInJlYWQiLCJsZW5ndGgiLCJ3cml0dGVuIiwicGFzc1N0cmluZ1RvV2FzbTAiLCJtYWxsb2MiLCJyZWFsbG9jIiwidW5kZWZpbmVkIiwibWVtIiwib2Zmc2V0IiwiY29kZSIsImNoYXJDb2RlQXQiLCJzbGljZSIsInJldCIsIkVkaXRvckZpbmFsaXphdGlvbiIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwiX193YmdfZWRpdG9yX2ZyZWUiLCJFZGl0b3IiLCJfX3dyYXAiLCJvYmoiLCJPYmplY3QiLCJjcmVhdGUiLCJwcm90b3R5cGUiLCJfX3diZ19wdHIiLCJfX2Rlc3Ryb3lfaW50b19yYXciLCJmcmVlIiwibmV3X2VtcHR5IiwiZWRpdG9yX25ldyIsImZyb21fanNvbiIsImpzb24iLCJwdHIwIiwiX193YmluZGdlbl9tYWxsb2MiLCJfX3diaW5kZ2VuX3JlYWxsb2MiLCJsZW4wIiwiZWRpdG9yX2Zyb21fanNvbiIsInRvX2pzb24iLCJkZWZlcnJlZDFfMCIsImRlZmVycmVkMV8xIiwiZWRpdG9yX3RvX2pzb24iLCJfX3diaW5kZ2VuX2ZyZWUiLCJ0b19odG1sIiwiZWRpdG9yX3RvX2h0bWwiLCJ0b19tYXJrZG93biIsImVkaXRvcl90b19tYXJrZG93biIsImluc2VydF90YWJsZSIsInJvd3MiLCJjb2xzIiwiZWRpdG9yX2luc2VydF90YWJsZSIsImFkZF9yb3ciLCJhdCIsImVkaXRvcl9hZGRfcm93IiwiYWRkX2NvbCIsImVkaXRvcl9hZGRfY29sIiwibW92ZV9yb3ciLCJmcm9tIiwidG8iLCJlZGl0b3JfbW92ZV9yb3ciLCJtb3ZlX2NvbCIsImVkaXRvcl9tb3ZlX2NvbCIsIm1lcmdlX2NlbGxzIiwic3IiLCJzYyIsImVyIiwiZWMiLCJlZGl0b3JfbWVyZ2VfY2VsbHMiLCJzcGxpdF9jZWxsIiwiciIsImMiLCJlZGl0b3Jfc3BsaXRfY2VsbCIsInNldF9jZWxsX3N0eWxlIiwic3R5bGVfanNvbiIsImVkaXRvcl9zZXRfY2VsbF9zdHlsZSIsInNldF9jb2x1bW5fd2lkdGgiLCJjb2wiLCJweCIsImVkaXRvcl9zZXRfY29sdW1uX3dpZHRoIiwic2V0X2ZyZWV6ZSIsImhlYWRlciIsImZpcnN0X2NvbCIsImVkaXRvcl9zZXRfZnJlZXplIiwidW5kbyIsImVkaXRvcl91bmRvIiwicmVkbyIsImVkaXRvcl9yZWRvIiwiYWRkX2NvbW1lbnQiLCJhbmNob3JfanNvbiIsInRleHQiLCJkZWZlcnJlZDNfMCIsImRlZmVycmVkM18xIiwicHRyMSIsImxlbjEiLCJlZGl0b3JfYWRkX2NvbW1lbnQiLCJyZXNvbHZlX2NvbW1lbnQiLCJ0aHJlYWRfaWQiLCJyZXNvbHZlZCIsImVkaXRvcl9yZXNvbHZlX2NvbW1lbnQiLCJjb25zdHJ1Y3RvciIsIkVYUEVDVEVEX1JFU1BPTlNFX1RZUEVTIiwiU2V0IiwiX193YmdfbG9hZCIsIm1vZHVsZSIsImltcG9ydHMiLCJSZXNwb25zZSIsIldlYkFzc2VtYmx5IiwiaW5zdGFudGlhdGVTdHJlYW1pbmciLCJlIiwidmFsaWRSZXNwb25zZSIsIm9rIiwiaGFzIiwidHlwZSIsImhlYWRlcnMiLCJnZXQiLCJjb25zb2xlIiwid2FybiIsImJ5dGVzIiwiYXJyYXlCdWZmZXIiLCJpbnN0YW50aWF0ZSIsImluc3RhbmNlIiwiSW5zdGFuY2UiLCJfX3diZ19nZXRfaW1wb3J0cyIsIndiZyIsIl9fd2JnX3diaW5kZ2VudGhyb3dfNGMxMWEyNGZjYTQyOWNjZiIsImFyZzAiLCJhcmcxIiwiX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZSIsInRhYmxlIiwiX193YmluZGdlbl9leHBvcnRfMCIsImdyb3ciLCJfX3diZ19pbml0X21lbW9yeSIsIl9fd2JnX2ZpbmFsaXplX2luaXQiLCJleHBvcnRzIiwiX193YmdfaW5pdCIsIl9fd2JpbmRnZW5fd2FzbV9tb2R1bGUiLCJfX3diaW5kZ2VuX3N0YXJ0IiwiaW5pdFN5bmMiLCJnZXRQcm90b3R5cGVPZiIsIk1vZHVsZSIsIm1vZHVsZV9vcl9wYXRoIiwiVVJMIiwidXJsIiwiUmVxdWVzdCIsImZldGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../core-wasm/pkg/smart_rte_wasm.js\n"));

/***/ })

}]);